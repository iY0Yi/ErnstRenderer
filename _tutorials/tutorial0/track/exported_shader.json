{"ver": "0.1", "renderpass": [{"outputs": [], "inputs": [], "name": "Common", "description": "", "type": "common", "code": "void offsetCanvasCoord(inout vec2 coord, vec2 res){\n  return;\n}\n\n#define ERNST_RENDER_SCALE float(1.)\n#define INV_ERNST_RENDER_SCALE (1./ERNST_RENDER_SCALE)\n#define PI acos(-1.)\n#define TAU (PI*2.)\n#define AXIS_X vec3(1, 0, 0)\n#define AXIS_Y vec3(0, 1, 0)\n#define AXIS_Z vec3(0, 0, 1)\n#define sat(x) clamp(x, 0., 1.)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define sstep(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define sign1f(x) ((x>0.) ? 1. : -1.)\n#define sign2v(v) vec2(sign1f(v.x), sign1f(v.y))\n#define linearstep(edge0, edge1, x) min(max((x-(edge0))/((edge1)-(edge0)), 0.), 1.)\n#define dot2(v) dot(v, v)\n// normalized atan.\nfloat natan(float y, float x){return atan(y, x)/acos(-1.)*.5+.5;}\nvec2 pow2(vec2 v, float power){return pow(v, vec2(power));}\nvec3 pow3(vec3 v, float power){return pow(v, vec3(power));}\nfloat sabs(float x, float k){float a=(.5/k)*x*x+k*.5;\n  float b=abs(x);\n  return b<k ? a : b;\n}\n// https://www.shadertoy.com/view/XdV3W3\nvec2 bx_cos(vec2 a){return clamp(abs(mod(a, 8.0)-4.0)-2.0, -1.0, 1.0);}\nvec2 bx_cossin(float a){return bx_cos(vec2(a, a-2.0));}\n// \"hash11()\"-\"hash44()\"\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins. May 2018\n// https://www.shadertoy.com/view/XdGfRR\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0/float(0xffffffffU))\nfloat hash11(float p){\n  uvec2 n=uint(int(p))*UI2;\n  uint q=(n.x ^ n.y)*UI0;\n  return float(q)*UIF;\n}\nfloat hash12(vec2 p){\n  uvec2 q=uvec2(ivec2(p))*UI2;\n  uint n=(q.x ^ q.y)*UI0;\n  return float(n)*UIF;\n  }float hash13(vec3 p){\n  uvec3 q=uvec3(ivec3(p))*UI3;\n  uint n=(q.x ^ q.y ^ q.z)*UI0;\n  return float(n)*UIF;\n}\nvec2 hash21(float p){\n  uvec2 n=uint(int(p))*UI2;\n  n=(n.x ^ n.y)*UI2;\n  return vec2(n)*UIF;\n}\nvec2 hash22(vec2 p){\n  uvec2 q=uvec2(ivec2(p))*UI2;\n  q=(q.x ^ q.y)*UI2;\n  return vec2(q)*UIF;\n}\nvec2 hash23(vec3 p){\n  uvec3 q=uvec3(ivec3(p))*UI3;\n  uvec2 n=(q.x ^ q.y ^ q.z)*UI2;\n  return vec2(n)*UIF;\n}\nvec3 hash33(vec3 p){\n  uvec3 q=uvec3(ivec3(p))*UI3;\n  q=(q.x ^ q.y ^ q.z)*UI3;\n  return vec3(q)*UIF;\n}\nvec3 hash32(vec2 q){\n  uvec3 n=uvec3(ivec3(q.xyx))*UI3;\n  n=(n.x ^ n.y ^ n.z)*UI3;\n  return vec3(n)*UIF;\n}\nvec3 hash31(float p){\n  uvec3 n=uint(int(p))*UI3;\n  n=(n.x ^ n.y ^ n.z)*UI3;\n  return vec3(n)*UIF;\n}\nvec4 hash43(vec3 p){\n  uvec4 q=uvec4(ivec4(p.xyzx))*UI4;\n  q=(q.x ^ q.y ^ q.z ^ q.w)*UI4;\n  return vec4(q)*UIF;\n}\n// FBMs\n// https://postd.cc/understanding-perlin-noise/\nfloat gnoise(in vec2 st){\n  st*=.75;\n  vec2 i=floor(st);\n  vec2 f=fract(st);\n  vec2 u=smoothstep(0., 1., f);\n  vec2 rnd_x0y0=u2s(hash22(i+vec2(0, 0)));\n  vec2 rnd_x1y0=u2s(hash22(i+vec2(1, 0)));\n  vec2 rnd_x0y1=u2s(hash22(i+vec2(0, 1)));\n  vec2 rnd_x1y1=u2s(hash22(i+vec2(1, 1)));\n  vec2 dir_x0y0=st-(i+vec2(0, 0));\n  vec2 dir_x1y0=st-(i+vec2(1, 0));\n  vec2 dir_x0y1=st-(i+vec2(0, 1));\n  vec2 dir_x1y1=st-(i+vec2(1, 1));\n  float dot_x0y0=dot(rnd_x0y0, dir_x0y0);\n  float dot_x1y0=dot(rnd_x1y0, dir_x1y0);\n  float dot_x0y1=dot(rnd_x0y1, dir_x0y1);\n  float dot_x1y1=dot(rnd_x1y1, dir_x1y1);\n  float res_x=mix(dot_x0y0, dot_x1y0, u.x);\n  float res_y=mix(dot_x0y1, dot_x1y1, u.x);\n  return s2u(mix(res_x, res_y, u.y)*2.);\n}\n// \"Noise-gradient-3D\" by iq:\n// https://www.shadertoy.com/view/Xsl3Dl\n// 0: cubic\n// 1: quintic\n#define INTERPOLANT 0\nfloat gnoise(in vec3 p){\n  vec3 i=floor(p);\n  vec3 f=fract(p);\n  #if INTERPOLANT==1\n  // quintic interpolant\n  vec3 u=f*f*f*(f*(f*6.-15.)+10.);\n  #else\n  // cubic interpolant\n  vec3 u=f*f*(3.-2.*f);\n  #endif\n  return mix(mix(mix(dot(hash33(i+vec3(0, 0, 0)), f-vec3(0, 0, 0)),\n  dot(hash33(i+vec3(1, 0, 0)), f-vec3(1, 0, 0)), u.x),\n  mix(dot(hash33(i+vec3(0, 1, 0)), f-vec3(0, 1, 0)),\n  dot(hash33(i+vec3(1, 1, 0)), f-vec3(1, 1, 0)), u.x), u.y),\n  mix(mix(dot(hash33(i+vec3(0, 0, 1)), f-vec3(0, 0, 1)),\n  dot(hash33(i+vec3(1, 0, 1)), f-vec3(1, 0, 1)), u.x),\n  mix(dot(hash33(i+vec3(0, 1, 1)), f-vec3(0, 1, 1)),\n  dot(hash33(i+vec3(1, 1, 1)), f-vec3(1, 1, 1)), u.x), u.y), u.z);\n}// fbm base for all noise\n#define fbm_base(nname, n, rep, pers){\\\n  float total=0.;\\\n  float frequency=1.;\\\n  float amplitude=1.;\\\n  float maxValue=0.;\\\n  for(int i=0;i<rep;i++){\\\n    total+=nname(vec2(n.x*frequency, n.y*frequency))*amplitude;\\\n    maxValue+=amplitude;\\\n    amplitude*=pers;\\\n    frequency*=2.;\\\n  }\\\n  res=total/maxValue;\\\n}\nfloat gfbm(vec2 n, int rep, float pers){\n  float res=0.;\n  fbm_base(gnoise, n, rep, pers);\n  return res;\n}\n// Data packer/unpacker\n// albedo, diffuse, specular, shadow, normal, and depth are rendered in raymarching pass,\n// and then, those results packed in one vec4 to use in post processing.\n// here are some experiments:\n// https://www.shadertoy.com/view/Ws3cRS\nuint packSnorm3x10(vec3 x){\n  x=round(clamp(x, -1., 1.) *.997*511.);\n  uvec3 sig=uvec3(mix(vec3(0), vec3(1), greaterThanEqual(sign(x), vec3(0))));\n  uvec3 mag=uvec3(abs(x));\n  uvec3 r=sig.xyz<<9 | mag.xyz;\n  return r.x<<22 | r.y<<12 | r.z<<2;\n}\n#define packS3(x) uintBitsToFloat(packSnorm3x10(x))\nvec3 unpackSnorm3x10(uint x){\n  uvec3 r=(uvec3(x)>>uvec3(22, 12, 2)) & uvec3(0x3FF);\n  uvec3 sig=r>>9;\n  uvec3 mag=r & uvec3(0x1FF);\n  vec3 fsig=mix(vec3(-1), vec3(1), greaterThanEqual(sig, uvec3(1)));\n  vec3 fmag=vec3(mag)/511.;\n  return fsig*fmag;\n}\n#define unpackS3(x) unpackSnorm3x10(floatBitsToUint(x))\nuint packUnorm3x10(vec3 x){\n  x=round(clamp(x, 0., 1.)*1023.);\n  uvec3 r=uvec3(x);\n  return r.x<<22 | r.y<<12 | r.z<<2;\n}\n#define packU3(x) uintBitsToFloat(packUnorm3x10(x))\nvec3 unpackUnorm3x10(uint x){\n  uvec3 r=(uvec3(x)>>uvec3(22, 12, 2)) & uvec3(0x3FF);\n  vec3 v=vec3(r)/1023.0;\n  return v;\n}\n#define unpackU3(x) unpackUnorm3x10(floatBitsToUint(x))\nuint packUnorm4x8(vec4 x){\n  x=round(clamp(x, 0., 1.)*255.);\n  uvec4 r=uvec4(x);\n  return r.x<<24 | r.y<<16 | r.z<<8 | r.w;\n}\n#define packU4(x) uintBitsToFloat(packUnorm4x8(x))\nvec4 unpackUnorm4x8(uint x){\n  uvec4 r=(uvec4(x)>>uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n  vec4 v=vec4(r)/255.0;\n  return v;\n}\n#define unpackU4(x) unpackUnorm4x8(floatBitsToUint(x))\n// Smoothstep alternatives\n// ---------------------------------------------------------------------\nfloat sigmoidstep(float edge0, float edge1, float x, float contrast, float mid){\n  // https://www.shadertoy.com/view/3ssSz2\n  x=smoothstep(edge0, edge1, x);\n  float scale_l=(1./mid)*x;\n  float scale_h=(1./(1.-mid))-(1./(1.-mid))*x;\n  float lower=mid*(scale_l*scale_l);\n  float upper=1.-(1.-mid)*(scale_h*scale_h);\n  float curve=x<mid ? lower : upper;\n  return mix(x, curve, (contrast-1.));\n}\nfloat smoothbistep(float edge0, float edge1, float x, float smoothness){\n  float l=abs(edge0-edge1)*smoothness*.5;\n  return (edge0<edge1) ? max(smoothstep(edge1-l, edge1, x), smoothstep(edge0+l, edge0, x)) : min(smoothstep(edge1-l, edge1, x), smoothstep(edge0+l, edge0, x));\n}\nfloat gainstep(float edge0, float edge1, float x, float k){\n  x=clamp((x-edge0)/(edge1-edge0), 0., 1.);\n  float a=.5*pow(2.*((x<.5) ? x : 1.-x), k);\n  return (x<.5) ? a : 1.-a;\n}\nfloat sigmoidbistep(float edge0, float edge1, float x, float smoothness, float contrast, float mid){\n  float l=abs(edge0-edge1)*smoothness*.5;\n  return (edge0<edge1) ? max(sigmoidstep(edge1-l, edge1, x, contrast, mid), sigmoidstep(edge0+l, edge0, x, contrast, mid)) : min(sigmoidstep(edge1-l, edge1, x, contrast, mid), sigmoidstep(edge0+l, edge0, x, contrast, mid));\n}\nfloat smoothsign(float x, float smoothness){\n  x=smoothstep(-smoothness, smoothness, x);\n  return x*2.-1.;\n}\nvec2 smoothsign(vec2 x, float smoothness){\n  x=smoothstep(-smoothness, smoothness, x);\n  return x*2.-1.;\n}\nvec3 smoothsign(vec3 x, float smoothness){\n  x=smoothstep(-smoothness, smoothness, x);\n  return x*2.-1.;\n}\n// hermitian completion to both sides of an edge. easy to tinkering a mask.\nfloat bismoothstep(float edge, float grad, float sat, float x){\n  grad*=.5, sat*=.5;\n  return smoothstep(edge-sat-grad, edge-sat, x) *\n  smoothstep(edge+sat+grad, edge+sat, x);\n}\n// just multailly 2 smoothsteps, but useful for masking an range.\nfloat wsmoothstep(float edge0, float edge1, float edge2, float edge3, float x){\n  return smoothstep(edge0, edge1, x)*smoothstep(edge3, edge2, x);\n}\n// https://en.wikipedia.org/wiki/Smoothstep\nfloat smootherstep(float edge0, float edge1, float x){\n  // Scale, and clamp x to 0..1 range\n  x=clamp((x-edge0)/(edge1-edge0), 0., 1.);\n  // Evaluate polynomial\n  return x*x*x*(x*(x*6.-15.)+10.);\n}\nstruct FBO {\n  vec3 albedo;\n  vec3 normal;\n  float diffuse;\n  float specular;\n  float shadow;\n  float ao;\n  float depth;\n  vec3 result;\n};\nFBO fbo;\nFBO fboPre;\nstruct Ray {\n  vec3 origin;\n  vec3 progress;\n  vec3 direction;\n};\nstruct Camera {\n  vec3 position;\n  float orthoDist;\n  vec3 direction;\n  float orthoScale;\n  vec3 target;\n  float fov;\n  vec4 quaternion;\n  vec3 pivot;\n  vec3 up;\n  bool is_perspective;\n};\nstruct Light {\n  vec3 direction;\n  float intensity;\n  vec3 color;\n  float shadowStart;\n  float shadowEnd;\n  float shadowSoft;\n};\n#define MIN_DIST .0001\n#define MAX_DIST 2000.\n#define ITERATION 168\n#define MAT_VOID vec3(-1)\n#define MAT_ERNST0_001_COL vec3(.613209, .315432, 0.)\n#define MAT_ERNST0_001_SPEC_ROUGHNESS .5\n#define MAT_ERNST0_001_SPEC_INTENSITY .4\n\n#define MAT_ERNST0_002_COL vec3(.40846, .310156, .224413)\n#define MAT_ERNST0_002_SPEC_ROUGHNESS .5\n#define MAT_ERNST0_002_SPEC_INTENSITY .4\n\n#define MAT_ERNST0_003_COL vec3(.615076, .000018, .000112)\n#define MAT_ERNST0_003_SPEC_ROUGHNESS .5\n#define MAT_ERNST0_003_SPEC_INTENSITY .4\n\n#define MAT_ERNST0_004_COL vec3(.001403, .072145, .614003)\n#define MAT_ERNST0_004_SPEC_ROUGHNESS .5\n#define MAT_ERNST0_004_SPEC_INTENSITY .4\n\n#define MAT_ERNST0_005_COL vec3(.617002, .256837, 0.)\n#define MAT_ERNST0_005_SPEC_ROUGHNESS .5\n#define MAT_ERNST0_005_SPEC_INTENSITY .4\n\n#define MAT_ERNST0_006_COL vec3(.06644, .002457, .394038)\n#define MAT_ERNST0_006_SPEC_ROUGHNESS .5\n#define MAT_ERNST0_006_SPEC_INTENSITY .4\n\n#define MAT_ERNST0_007_COL vec3(.000274, .614354, .005983)\n#define MAT_ERNST0_007_SPEC_ROUGHNESS .5\n#define MAT_ERNST0_007_SPEC_INTENSITY .4\n\n#define MAT_ERNST0_008_COL vec3(.001107, .001107, .001107)\n#define MAT_ERNST0_008_SPEC_ROUGHNESS .5\n#define MAT_ERNST0_008_SPEC_INTENSITY .4\n\n#define MAT_ERNST0_009_COL vec3(.000674, .00085, .000715)\n#define MAT_ERNST0_009_SPEC_ROUGHNESS .5\n#define MAT_ERNST0_009_SPEC_INTENSITY .4\n\n#define MAT_ERNST0_010_COL vec3(0., .000585, .198241)\n#define MAT_ERNST0_010_SPEC_ROUGHNESS .5\n#define MAT_ERNST0_010_SPEC_INTENSITY .4\n\n#define MAT_ERNST0_011_COL vec3(.614956, .209726, 0.)\n#define MAT_ERNST0_011_SPEC_ROUGHNESS .5\n#define MAT_ERNST0_011_SPEC_INTENSITY .4\n\n#define MAT_ERNST0_012_COL vec3(.197887, .000085, 0.)\n#define MAT_ERNST0_012_SPEC_ROUGHNESS .5\n#define MAT_ERNST0_012_SPEC_INTENSITY .4\n\n#define MAT_ERNST0_013_COL vec3(.000091, .000091, .000091)\n#define MAT_ERNST0_013_SPEC_ROUGHNESS .5\n#define MAT_ERNST0_013_SPEC_INTENSITY .4\n\n#define MAT_ERNST0_014_COL vec3(.871207, .994663, .864131)\n#define MAT_ERNST0_014_SPEC_ROUGHNESS .5\n#define MAT_ERNST0_014_SPEC_INTENSITY .4\n\nbool isMaterial(vec3 MAT){\n  const float MAT_EPS=1e-5;\n  vec3 diff=fbo.albedo-MAT;\n  return dot(diff, diff)<MAT_EPS*MAT_EPS;\n}\nvoid getMaterialParams(vec3 MAT, inout float specular, inout float roughness){\n  \n  if(isMaterial(MAT_ERNST0_001_COL)){\n    specular=MAT_ERNST0_001_SPEC_ROUGHNESS;\n    roughness=MAT_ERNST0_001_SPEC_INTENSITY;\n    return;\n  }\n  \n  if(isMaterial(MAT_ERNST0_002_COL)){\n    specular=MAT_ERNST0_002_SPEC_ROUGHNESS;\n    roughness=MAT_ERNST0_002_SPEC_INTENSITY;\n    return;\n  }\n  \n  if(isMaterial(MAT_ERNST0_003_COL)){\n    specular=MAT_ERNST0_003_SPEC_ROUGHNESS;\n    roughness=MAT_ERNST0_003_SPEC_INTENSITY;\n    return;\n  }\n  \n  if(isMaterial(MAT_ERNST0_004_COL)){\n    specular=MAT_ERNST0_004_SPEC_ROUGHNESS;\n    roughness=MAT_ERNST0_004_SPEC_INTENSITY;\n    return;\n  }\n  \n  if(isMaterial(MAT_ERNST0_005_COL)){\n    specular=MAT_ERNST0_005_SPEC_ROUGHNESS;\n    roughness=MAT_ERNST0_005_SPEC_INTENSITY;\n    return;\n  }\n  \n  if(isMaterial(MAT_ERNST0_006_COL)){\n    specular=MAT_ERNST0_006_SPEC_ROUGHNESS;\n    roughness=MAT_ERNST0_006_SPEC_INTENSITY;\n    return;\n  }\n  \n  if(isMaterial(MAT_ERNST0_007_COL)){\n    specular=MAT_ERNST0_007_SPEC_ROUGHNESS;\n    roughness=MAT_ERNST0_007_SPEC_INTENSITY;\n    return;\n  }\n  \n  if(isMaterial(MAT_ERNST0_008_COL)){\n    specular=MAT_ERNST0_008_SPEC_ROUGHNESS;\n    roughness=MAT_ERNST0_008_SPEC_INTENSITY;\n    return;\n  }\n  \n  if(isMaterial(MAT_ERNST0_009_COL)){\n    specular=MAT_ERNST0_009_SPEC_ROUGHNESS;\n    roughness=MAT_ERNST0_009_SPEC_INTENSITY;\n    return;\n  }\n  \n  if(isMaterial(MAT_ERNST0_010_COL)){\n    specular=MAT_ERNST0_010_SPEC_ROUGHNESS;\n    roughness=MAT_ERNST0_010_SPEC_INTENSITY;\n    return;\n  }\n  \n  if(isMaterial(MAT_ERNST0_011_COL)){\n    specular=MAT_ERNST0_011_SPEC_ROUGHNESS;\n    roughness=MAT_ERNST0_011_SPEC_INTENSITY;\n    return;\n  }\n  \n  if(isMaterial(MAT_ERNST0_012_COL)){\n    specular=MAT_ERNST0_012_SPEC_ROUGHNESS;\n    roughness=MAT_ERNST0_012_SPEC_INTENSITY;\n    return;\n  }\n  \n  if(isMaterial(MAT_ERNST0_013_COL)){\n    specular=MAT_ERNST0_013_SPEC_ROUGHNESS;\n    roughness=MAT_ERNST0_013_SPEC_INTENSITY;\n    return;\n  }\n  \n  if(isMaterial(MAT_ERNST0_014_COL)){\n    specular=MAT_ERNST0_014_SPEC_ROUGHNESS;\n    roughness=MAT_ERNST0_014_SPEC_INTENSITY;\n    return;\n  }\n  \n}\n#define AMB_COL vec3(1., .382855, .001157)\n#define AMB_STRENGTH .2\n#define FOG_COL vec3(0)\n#define FOG_START 0.\n#define FOG_POW 1.\n// Climbers and Watchers have 16 poses each.\n// It's like a sprite sheet on NES :)\n// TRV is variables for Transformation.\n#define TRVS_NUM 0\nuint TRVsID=0U;\n#define IS_EDITING_TRVS 0\n// Lists of no overwrapped random ids.\n// here is the list generator:\n// https://codepen.io/iy0yi/pen/qBXoGBp?editors=0011\n#define IDS_ALL_TABLE_NUM 160\nconst int[IDS_ALL_TABLE_NUM] ids_All=int[](10, 15, 14, 8, 3, 2, 6, 7, 13, 12, 5, 11, 1, 9, 4, 0, 12, 9, 13, 11, 1, 5, 10, 7, 14, 0, 8, 6, 3, 15, 4, 2, 15, 10, 14, 0, 4, 12, 11, 7, 9, 13, 2, 1, 3, 6, 8, 5, 1, 5, 2, 10, 4, 15, 6, 12, 11, 0, 14, 9, 8, 7, 3, 13, 8, 3, 9, 0, 12, 4, 2, 7, 13, 11, 6, 10, 5, 15, 14, 1, 12, 14, 9, 13, 11, 0, 15, 6, 7, 3, 10, 2, 4, 1, 5, 8, 14, 1, 11, 8, 15, 0, 5, 6, 10, 4, 7, 13, 12, 3, 9, 2, 1, 14, 2, 0, 13, 12, 10, 5, 9, 15, 8, 4, 11, 6, 7, 3, 13, 2, 10, 3, 1, 8, 12, 5, 0, 7, 14, 15, 9, 11, 6, 4, 13, 2, 12, 4, 7, 1, 6, 10, 11, 9, 15, 14, 3, 8, 0, 5);// 0-15\n#define TRVS_ID_C_DEFAULT 0\n#define TRVS_ID_C_OFFSETED 1\n#define TRVS_ID_C_PATIENT 2\n#define TRVS_ID_C_PATIENT_FALLING 3\n#define TRVS_ID_C_FALLING 4\n#define IDS_C_DEFALUT_TABLE_NUM 110\nconst int[IDS_C_DEFALUT_TABLE_NUM] ids_C_Default=int[](7, 3, 6, 1, 5, 8, 4, 0, 10, 9, 3, 4, 5, 0, 8, 7, 1, 3, 2, 6, 10, 9, 10, 4, 7, 1, 0, 3, 2, 9, 8, 6, 5, 4, 3, 6, 9, 7, 2, 8, 1, 10, 0, 5, 0, 7, 2, 4, 2, 5, 6, 8, 1, 9, 10, 0, 8, 4, 6, 5, 10, 2, 1, 3, 9, 7, 5, 4, 3, 9, 8, 2, 7, 0, 10, 6, 1, 0, 6, 10, 5, 4, 1, 3, 7, 8, 2, 9, 8, 6, 9, 3, 2, 0, 7, 10, 5, 1, 4, 2, 1, 0, 10, 8, 9, 7, 6, 4, 5, 3);// 0-10\n#define IDS_C_OFFSETED_TABLE_NUM 60\nconst int[IDS_C_OFFSETED_TABLE_NUM] ids_C_Offseted=int[](2, 5, 0, 1, 4, 3, 4, 2, 3, 5, 2, 0, 4, 2, 3, 0, 1, 5, 4, 2, 5, 3, 4, 0, 2, 1, 0, 5, 4, 3, 1, 2, 5, 5, 0, 4, 1, 5, 0, 2, 4, 3, 2, 0, 4, 3, 1, 5, 2, 1, 0, 4, 3, 5, 2, 3, 5, 1, 0, 4);// 0-5\n#define IDS_C_PATIENT_TABLE_NUM 30\nconst int[IDS_C_PATIENT_TABLE_NUM] ids_C_Patient=int[](12, 13, 11, 12, 13, 11, 13, 11, 12, 11, 12, 13, 11, 12, 13, 11, 13, 12, 11, 13, 12, 11, 13, 12, 13, 11, 12, 13, 11, 12);// 11-13\n#define IDS_C_PATIENT_FALLING_TABLE_NUM 50\nconst int[IDS_C_PATIENT_FALLING_TABLE_NUM] ids_C_Patient_Falling=int[](12, 15, 13, 11, 14, 13, 12, 14, 11, 15, 11, 13, 15, 12, 14, 13, 14, 11, 12, 15, 14, 12, 11, 15, 13, 15, 14, 12, 11, 13, 12, 11, 14, 13, 15, 12, 15, 11, 14, 13, 14, 11, 15, 12, 13, 14, 11, 12, 15, 13);// 11-15\n#define IDS_C_FALLING_TABLE_NUM 10\nconst int[IDS_C_FALLING_TABLE_NUM] ids_C_Falling=int[](14, 15, 14, 15, 14, 15, 14, 15, 14, 15);// 14-15\n#define TRVS_ID_W_LIFTING 5\n#define TRVS_ID_W_CARRYING 6\n#define TRVS_ID_W_OPENNING 7\n#define TRVS_ID_W_CLOSED 8\n#define TRVS_ID_W_PEEPING 9\n#define TRVS_ID_W_DROPPING 10\n#define TRVS_ID_W_VIEWING 11\n#define TRVS_ID_W_GENERAL 12\n#define IDS_W_LIFTING_TABLE_NUM 1\nconst int[IDS_W_LIFTING_TABLE_NUM] ids_W_Lifting=int[](0);// 0\n#define IDS_W_CARRYING_TABLE_NUM 10\nconst int[IDS_W_CARRYING_TABLE_NUM] ids_W_Carrying=int[](2, 1, 1, 2, 1, 2, 1, 2, 2, 1);// 1-2\n#define IDS_W_OPENNING_TABLE_NUM 15\nconst int[IDS_W_OPENNING_TABLE_NUM] ids_W_Openning=int[](4, 3, 5, 3, 5, 4, 3, 4, 5, 4, 5, 3, 5, 3, 4);// 3-5\n#define IDS_W_CLOSED_TABLE_NUM 1\nconst int[IDS_W_CLOSED_TABLE_NUM] ids_W_Closed=int[](6);// 6\n#define IDS_W_PEEPING_TABLE_NUM 15\nconst int[IDS_W_PEEPING_TABLE_NUM] ids_W_Peeping=int[](8, 7, 9, 8, 9, 7, 9, 8, 7, 7, 9, 8, 8, 9, 7);// 7-9\n#define IDS_W_DROPPING_TABLE_NUM 10\nconst int[IDS_W_DROPPING_TABLE_NUM] ids_W_Dropping=int[](10, 11, 10, 11, 10, 11, 10, 11, 11, 10);// 10-11\n#define IDS_W_VIEWING_TABLE_NUM 15\nconst int[IDS_W_VIEWING_TABLE_NUM] ids_W_Viewing=int[](12, 14, 13, 12, 14, 13, 13, 14, 12, 13, 12, 14, 14, 12, 13);// 12-14\n#define IDS_W_GENERAL_TABLE_NUM 1\nconst int[IDS_W_GENERAL_TABLE_NUM] ids_W_General=int[](15);// 15\nint getId(float pid, int idType){\n  switch(idType){\n    case TRVS_ID_C_DEFAULT:\n    return ids_C_Default[int(IDS_C_DEFALUT_TABLE_NUM-1-int(mod(pid, float(IDS_C_DEFALUT_TABLE_NUM))))];\n    case TRVS_ID_C_OFFSETED:\n    return ids_C_Offseted[int(IDS_C_OFFSETED_TABLE_NUM-1-int(mod(pid, float(IDS_C_OFFSETED_TABLE_NUM))))];\n    case TRVS_ID_C_PATIENT:\n    return ids_C_Patient[int(IDS_C_PATIENT_TABLE_NUM-1-int(mod(pid, float(IDS_C_PATIENT_TABLE_NUM))))];\n    case TRVS_ID_C_PATIENT_FALLING:\n    return ids_C_Patient_Falling[int(IDS_C_PATIENT_FALLING_TABLE_NUM-1-int(mod(pid, float(IDS_C_PATIENT_FALLING_TABLE_NUM))))];\n    case TRVS_ID_C_FALLING:\n    return ids_C_Falling[int(IDS_C_FALLING_TABLE_NUM-1-int(mod(pid, float(IDS_C_FALLING_TABLE_NUM))))];\n    case TRVS_ID_W_LIFTING:\n    return ids_W_Lifting[int(IDS_W_LIFTING_TABLE_NUM-1-int(mod(pid, float(IDS_W_LIFTING_TABLE_NUM))))];\n    case TRVS_ID_W_CARRYING:\n    return ids_W_Carrying[int(IDS_W_CARRYING_TABLE_NUM-1-int(mod(pid, float(IDS_W_CARRYING_TABLE_NUM))))];\n    case TRVS_ID_W_OPENNING:\n    return ids_W_Openning[int(IDS_W_OPENNING_TABLE_NUM-1-int(mod(pid, float(IDS_W_OPENNING_TABLE_NUM))))];\n    case TRVS_ID_W_CLOSED:\n    return ids_W_Closed[int(IDS_W_CLOSED_TABLE_NUM-1-int(mod(pid, float(IDS_W_CLOSED_TABLE_NUM))))];\n    case TRVS_ID_W_PEEPING:\n    return ids_W_Peeping[int(IDS_W_PEEPING_TABLE_NUM-1-int(mod(pid, float(IDS_W_PEEPING_TABLE_NUM))))];\n    case TRVS_ID_W_DROPPING:\n    return ids_W_Dropping[int(IDS_W_DROPPING_TABLE_NUM-1-int(mod(pid, float(IDS_W_DROPPING_TABLE_NUM))))];\n    case TRVS_ID_W_VIEWING:\n    return ids_W_Viewing[int(IDS_W_VIEWING_TABLE_NUM-1-int(mod(pid, float(IDS_W_VIEWING_TABLE_NUM))))];\n    case TRVS_ID_W_GENERAL:\n    return ids_W_General[int(IDS_W_GENERAL_TABLE_NUM-1-int(mod(pid, float(IDS_W_GENERAL_TABLE_NUM))))];\n    default:\n    return ids_All[int(mod(pid, float(IDS_ALL_TABLE_NUM-1)))];\n  }\n}\n// \"init\": init camera/lights.\n// ---------------------------------------------------------------------\nRay ray;\nCamera cam0;\nLight lit0;\nvoid init(){\n  cam0.position=vec3(-1.263111, 2.684501, 18.77784);\n  cam0.quaternion=vec4(.005948, -.7085, -.705661, -.005924);\n  cam0.fov=.302795;\n  cam0.orthoDist=0.;\n  cam0.orthoScale=0.;\n  \n  lit0.direction=normalize(vec3(.305914, .530884, .790303));\n  lit0.color=vec3(1., 1., 1.);\n  lit0.intensity=1.;\n  lit0.shadowStart=.05;\n  lit0.shadowEnd=30.;\n  lit0.shadowSoft=50.;\n  \n}\n// \"camera\": create camera vectors.\n// quaternion functions\nvec4 invQuat=vec4(1, 1, 1, -1);\nvec4 getQuat(vec3 ax, float a){\n  return vec4(normalize(ax)*sin(a*.5), cos(a*.5));\n}\nvec4 getQuat(vec3 curDir, vec3 trgtDir){\n  curDir=normalize(curDir);\n  trgtDir=normalize(trgtDir);\n  vec3 ax=cross(trgtDir, curDir);\n  float a=acos(dot(curDir, trgtDir));\n  return getQuat(ax, a);\n}\nvec4 mulQuat(vec4 q1, vec4 q2){\n  vec3 ax=q1.w*q2.xyz+q2.w*q1.xyz+cross(q1.xyz, q2.xyz);\n  float a=q1.w*q2.w-dot(q1.xyz, q2.xyz);\n  return vec4(ax, a);\n}\nvoid pRotQuat(inout vec3 p, vec4 quat){\n  p=p+2.*cross(quat.xyz, cross(quat.xyz, p)-quat.w*p);\n}\nvoid perspectiveCam(vec2 uv){\n  vec3 up=vec3(0, 1, 0);\n  vec3 dir=vec3(0, 0, -1);\n  pRotQuat(up, cam0.quaternion);\n  pRotQuat(dir, cam0.quaternion);\n  up=up.xzy, dir=dir.xzy;\n  vec3 pos=cam0.position;\n  float fov=cam0.fov;\n  vec3 target=pos-dir;\n  vec3 cw=normalize(target-pos);\n  vec3 cu=normalize(cross(cw, up));\n  vec3 cv=normalize(cross(cu, cw));\n  cam0.up=up;\n  mat3 camMat=mat3(cu, cv, cw);\n  ray.origin=pos;\n  ray.direction=normalize(camMat*normalize(vec3(sin(fov)*uv.x, sin(fov)*uv.y, -cos(fov))));\n}\nvoid camera(vec2 uv){\n  perspectiveCam(uv);\n}\nvec2 pRot2(inout vec2 p, float a){\n  p=cos(a)*p+sin(a)*vec2(p.y, -p.x);\n  return p;\n}\n// https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro){return mix(dot(ax, p)*ax, p, cos(ro))+cross(ax, p)*sin(ro);}\nvec3 erotX(vec3 p, float ro){return erot(p, vec3(1, 0, 0), ro);}\nvec3 erotY(vec3 p, float ro){return erot(p, vec3(0, 1, 0), ro);}\nvec3 erotZ(vec3 p, float ro){return erot(p, vec3(0, 0, 1), ro);}\nvec3 gBalloonCenter=vec3(0);\n// IK structs and functions\nstruct IKBone{\n  vec3 tail;\n  float len;\n  vec4 quat;\n};\nstruct IKArmature{\n  IKBone[3] bon;\n  vec3 pol;\n};\nvoid calcIK(inout IKArmature ika){\n  vec3 C=ika.bon[2].tail-ika.bon[0].tail;\n  float lenC=length(C);\n  // projection quaternion (2d to 3d)\n  vec4 prjQuat=getQuat(AXIS_Y, C);\n  // rotate the pole into the 2d space\n  vec3 pol=ika.pol-ika.bon[0].tail;\n  pRotQuat(pol, prjQuat*invQuat);\n  // add roll rotation\n  prjQuat=mulQuat(prjQuat, getQuat(C, PI-atan(pol.x, pol.z)));\n  // calc ik in projected 2d space\n  // ref about 2d ik:\"Foundation ActionScript 3.0 Animation\" P.367\n  float lenA=ika.bon[1].len,\n  lenB=ika.bon[2].len;\n  lenC=min(lenA+lenB, lenC);\n  float lenA2=lenA*lenA,\n  lenB2=lenB*lenB,\n  lenC2=lenC*lenC;\n  float angB=acos((lenB2-lenA2-lenC2)/(-2.*lenA*lenC)),\n  angC=acos((lenC2-lenA2-lenB2)/(-2.*lenA*lenB)),\n  angD=PI*.5,\n  angD_B=angD+angB,\n  angE=angB+angC+PI;\n  ika.bon[1].tail=vec3(0, sin(angD_B), cos(angD_B))*lenA;\n  // convert 2d bon[1].tail into original 3d space\n  pRotQuat(ika.bon[1].tail, prjQuat);\n  ika.bon[1].tail+=ika.bon[0].tail;\n  // store quaternions\n  ika.bon[0].quat=mulQuat(getQuat(AXIS_X, angB), prjQuat);\n  ika.bon[1].quat=mulQuat(getQuat(AXIS_X, angE), prjQuat);\n}\nvoid pIKRig(inout vec3 p, IKBone bon){\n  p+=bon.tail;\n  pRotQuat(p, bon.quat*invQuat);\n}\n// Read data from pre-pass\n// ---------------------------------------------------------------------\n#define getBuf(tex, coord) texelFetch(tex, ivec2(coord), 0)\nvec3 getAlbedo(sampler2D tex, vec2 coord){ return unpackU4(getBuf(tex, coord).x).rgb;}\nfloat getAO(sampler2D tex, vec2 coord){ return s2u(unpackS3(getBuf(tex, coord).y).b);}\nfloat getShadow(sampler2D tex, vec2 coord){ return unpackU4(getBuf(tex, coord).x).a;}\nfloat getDiffuse(sampler2D tex, vec2 coord){ float res=unpackS3(getBuf(tex, coord).y).r;\n  return s2u(res);\n}\nfloat getSpecular(sampler2D tex, vec2 coord){ return sat(unpackS3(getBuf(tex, coord).y).g);}\nfloat getCloudData(sampler2D tex, vec2 coord){ return unpackS3(getBuf(tex, coord).y).g;}\nfloat getDepth(sampler2D tex, vec2 coord){ return getBuf(tex, coord).w;}\nvec3 getNormal(sampler2D tex, vec2 coord){ return normalize(unpackS3(getBuf(tex, coord).z));}\nvoid initFBO(){\n  fbo=FBO(vec3(0), vec3(0), 0., 0., 0., 0., 0., vec3(0));\n  fboPre=FBO(vec3(0), vec3(0), 0., 0., 0., 0., 0., vec3(0));\n}\nvec4 packFBO(){\n  return vec4(\n  packU4(vec4(fbo.albedo, fbo.shadow)),\n  packS3(vec3(u2s(fbo.diffuse), fbo.specular, u2s(fbo.ao))),\n  packS3(fbo.normal),\n  fbo.depth\n  );\n}\nvoid unpackFBO(inout FBO fbo, sampler2D tex, vec2 coord){\n  fbo.albedo=getAlbedo(tex, coord);\n  fbo.shadow=getShadow(tex, coord);\n  fbo.diffuse=getDiffuse(tex, coord);\n  fbo.specular=getSpecular(tex, coord);\n  fbo.ao=getAO(tex, coord);\n  fbo.normal=getNormal(tex, coord);\n  fbo.depth=getDepth(tex, coord);\n}\n// Smooth Voronoi\n// https://iquilezles.org/www/articles/smoothvoronoi/smoothvoronoi.htm\nfloat sminC3(float a, float b, float r){\n  float n=max(0., 1.-abs(a-b)/r);\n  float o=(.25-n*.1)*((n*n)*(n*n));\n  return min(a, b)-o*r;\n}\nfloat voronoiSmooth(vec3 p, float s){\n  vec3 i=floor(p);\n  vec3 f=fract(p);\n  float res=8.;\n  for(int j=-1;j<=1;j++)\n  for(int k=-1;k<=1;k++)\n  for(int l=-1;l<=1;l++){\n    vec3 b=vec3(j, k, l);\n    vec3 r=b-f+hash33(i+b);\n    float d=length(r);\n    res=sminC3(res, d, s);\n  }\n  return res;\n}\n// Voronoi displacement for Clouds\nfloat vrn1=0.;\nfloat vrn2=0.;\nfloat vrn3=0.;\nfloat vrn4=0.;\nfloat vrn5=0.;\nvoid calcVrn(vec3 p){\n  vrn1=voronoiSmooth(p*.1, .1);\n  float freq=.3;\n  float smoothness=.01;\n  vrn2=(1.-voronoiSmooth(p*freq, smoothness*.5))*.6;\n  vrn3=(1.-voronoiSmooth(p*freq*2., smoothness*.5))*.25;\n  vrn4=(1.-voronoiSmooth(p*freq*4., smoothness*.5))*.15;\n  vrn5=(1.-voronoiSmooth(p*freq*16., smoothness*.5))*.035;\n}\n// \"SphericalFibonacci\" by EvilRyu:\n// https://www.shadertoy.com/view/dsjXDm\nconst float gNum=16.;\n// from http://gec.di.uminho.pt/psantos/Publications_ficheiros/SF_CGF2013.pdf\n// unoptimized version\n// j: index of the point to generate\nvec3 sphericalFibonacci(float j){\n  float phi=2.*PI*j*(2./(3.-sqrt(5.)));\n  float theta=acos(1.-2.*j/gNum);\n  return vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta));\n}\n// https://iquilezles.org/articles/intersectors\nvec2 iBox(vec3 ro, vec3 rd, vec3 size){\n  vec3 m=1./rd;\n  vec3 n=m*ro;\n  vec3 k=abs(m)*size;\n  vec3 t1=-n-k;\n  vec3 t2=-n+k;\n  float tN=max(max(t1.x, t1.y), t1.z);\n  float tF=min(min(t2.x, t2.y), t2.z);\n  if(tN>tF||tF<0.) return vec2(-1);\n  return vec2(tN, tF);\n}\nint getDigits(float f, int digc, int index){\n  f=f*pow(10., float(digc+index*digc));\n  return int(f) % int(pow(10., float(digc)));\n}\nbool inRange(float v, float min, float max){\n  return v>min && v<max;\n}\nbool inRange(int v, int min, int max){\n  return v>min && v<max;\n}\nfloat vmax(vec3 v){\n  return max(v.x, max(v.y, v.z));\n}\n#define CELL_SIZE vec3(10)\nvec3 gCurrentCell=vec3(0);\nvec3 getCell(vec3 p){\n  return vec3(floor(p/CELL_SIZE)*CELL_SIZE);\n}"}, {"outputs": [{"channel": 0, "id": "4dfGRr"}], "inputs": [{"channel": 0, "type": "buffer", "id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "sampler": {"filter": "nearest", "wrap": "wrap", "vflip": "true", "srgb": "false", "internal": "byte"}}], "name": "Image", "description": "", "type": "image", "code": "//SDF functions\n// oklab-optimized color mix by iq\n// https://www.shadertoy.com/view/ttcyRS\nvec3 oklab_mix(vec3 colA, vec3 colB, float h){\n  // https://bottosson.github.io/posts/oklab\n  const mat3 kCONEtoLMS=mat3(\n  0.4121656120,  0.2118591070,  0.0883097947,\n  0.5362752080,  0.6807189584,  0.2818474174,\n  0.0514575653,  0.1074065790,  0.6302613616);\n  const mat3 kLMStoCONE=mat3(\n  4.0767245293, -1.2681437731, -0.0041119885,\n  -3.3072168827,  2.6093323231, -0.7034763098,\n  0.2307590544, -0.3411344290,  1.7068625689);\n  colA=sat(colA);\n  colB=sat(colB);\n  // rgb to cone (arg of pow can't be negative)\n  vec3 lmsA=pow(sat(kCONEtoLMS*colA)+1e-6, vec3(1.0/3.0));\n  vec3 lmsB=pow(sat(kCONEtoLMS*colB)+1e-6, vec3(1.0/3.0));\n  // lerp\n  vec3 lms=mix(lmsA, lmsB, h);\n  // gain in the middle (no oaklab anymore, but looks better?)\n  // lms*=1.0+0.2*h*(1.0-h);\n  // cone to rgb\n  return kLMStoCONE*(lms*lms*lms);\n  }vec3 sub_mix(vec3 colA, vec3 colB, float factor){\n  // 1) \u30a4\u30f3\u30af\u7a7a\u9593\u306b\u5909\u63db (InkSpace=1-Color)\n  vec3 inkA=1.0-colA;\n  vec3 inkB=1.0-colB;\n  // 2) \u30a4\u30f3\u30af\u7a7a\u9593\u3067\u901a\u5e38\u306e\u7dda\u5f62\u88dc\u9593\n  //    factor=0.0 \u2192 inkA,  factor=1.0 \u2192 inkB\n  vec3 inkMix=mix(inkA, inkB, factor);\n  // 3) \u767a\u5149\u8272\u7a7a\u9593\u306b\u623b\u3059 (Color=1-Ink)\n  //    factor=0.0 \u2192 colA,  factor=1.0 \u2192 colB\n  return 1.0-inkMix;\n}//------------------------------------------------------\n// 1) RGB \u2192 RYB \u306e\u5909\u63db\n//------------------------------------------------------\nvec3 rgb2ryb(vec3 rgb_color){\n  // Remove the white from the color\n  float white=min(min(rgb_color.r, rgb_color.g), rgb_color.b);\n  rgb_color-=vec3(white);\n  float max_green=max(max(rgb_color.r, rgb_color.g), rgb_color.b);\n  // Get the yellow out of the red & green\n  float yellow=min(rgb_color.r, rgb_color.g);\n  rgb_color.r-=yellow;\n  rgb_color.g-=yellow;\n  // If there's leftover in both b & g, halve them (avoid exceeding range)\n  if (rgb_color.b>0. && rgb_color.g>0.){\n    rgb_color.b/=2.;\n    rgb_color.g/=2.;\n  }\n  // Redistribute the remaining green\n  yellow+=rgb_color.g;\n  rgb_color.b+=rgb_color.g;\n  // Normalize to values\n  float max_yellow=max(max(rgb_color.r, yellow), rgb_color.b);\n  if (max_yellow>0.){\n    float n=max_green/max_yellow;\n    rgb_color.r*=n;\n    yellow    *=n;\n    rgb_color.b*=n;\n  }\n  // Add the white back in\n  rgb_color.r+=white;\n  yellow     +=white;\n  rgb_color.b+=white;\n  return vec3(rgb_color.r, yellow, rgb_color.b);\n}\n//------------------------------------------------------\n// 2) RYB \u2192 RGB \u306e\u5909\u63db\n//------------------------------------------------------\nvec3 ryb2rgb(vec3 ryb_color){\n  // Remove the white\n  float white=min(min(ryb_color.r, ryb_color.g), ryb_color.b);\n  ryb_color-=vec3(white);\n  float max_yellow=max(max(ryb_color.r, ryb_color.g), ryb_color.b);\n  // Get the green out of the yellow & blue\n  float green=min(ryb_color.g, ryb_color.b);\n  ryb_color.g-=green;\n  ryb_color.b-=green;\n  if (ryb_color.b>0. && green>0.){\n    ryb_color.b*=2.;\n    green      *=2.;\n  }\n  // Redistribute the remaining yellow\n  ryb_color.r+=ryb_color.g;\n  green      +=ryb_color.g;\n  // Normalize\n  float max_green=max(max(ryb_color.r, green), ryb_color.b);\n  if (max_green>0.){\n    float n=max_yellow/max_green;\n    ryb_color.r*=n;\n    green      *=n;\n    ryb_color.b*=n;\n  }\n  // Add white back\n  ryb_color.r+=white;\n  green      +=white;\n  ryb_color.b+=white;\n  return vec3(ryb_color.r, green, ryb_color.b);\n}\n//------------------------------------------------------\n// 3) RYB\u3067\u6df7\u8272\u3057\u3064\u3064\u3001\u660e\u5ea6\u3092\u30d6\u30ec\u30f3\u30c9\u3059\u308b\u95a2\u6570\n//    \uff08mainImage\u306e\u30ed\u30b8\u30c3\u30af\u3092\u307e\u3068\u3081\u305f\u3082\u306e\uff09\n//------------------------------------------------------\nvec3 ryb_mix(vec3 colA, vec3 colB, float factor){\n  // 3-1) \u660e\u5ea6\u3092\u8a08\u7b97\u3059\u308b\u305f\u3081\u306e\u884c\u5217 M\n  //      (mainImage\u5185\u3067 mat3(0.241, 0, 0, 0, 0.691, 0, 0, 0, 0.068))\n  //      \u53c2\u8003: BT.601 \u3084\u8fd1\u3044\u4fc2\u6570\u304b\u3089\u6d3e\u751f\u3057\u305f\u3082\u306e\n  mat3 M=mat3(0.241, 0.0,   0.0,\n  0.0,   0.691, 0.0,\n  0.0,   0.0,   0.068);\n  // 3-2) \u5404\u8272\u306e\u300c\u660e\u5ea6\u300d(b1, b2) \u3092\u8a08\u7b97\n  float bA=sqrt(dot(colA, M*colA));\n  float bB=sqrt(dot(colB, M*colB));\n  // 3-3) RGB\u2192RYB\u3078\u5909\u63db\u5f8c\u306b\u7dda\u5f62\u88dc\u9593\n  vec3 rybA=rgb2ryb(colA);\n  vec3 rybB=rgb2ryb(colB);\n  vec3 rybMixed=mix(rybA, rybB, factor);\n  // 3-4) \u3044\u3063\u305f\u3093RYB\u2192RGB\u306b\u623b\u3057\u3066\u3001\u6df7\u8272\u5f8c\u306e\u660e\u5ea6\u3092\u8a08\u7b97\n  vec3 rgbMixed=ryb2rgb(rybMixed);\n  float bMixed  =sqrt(dot(rgbMixed, M*rgbMixed));\n  // 3-5) \u6700\u7d42\u7684\u306a\u660e\u5ea6\u3092 (bA, bB) \u304b\u3089 factor \u3067\u88dc\u9593\n  float bFinal=mix(bA, bB, factor);\n  // 3-6) bMixed \u304c 0 \u3067\u306a\u3051\u308c\u3070\u3001RYB\u4e0a\u3067\u30b9\u30b1\u30fc\u30eb\u3057\u3066\u660e\u5ea6\u3092\u5408\u308f\u305b\u308b\n  if (bMixed>1e-6){\n    rybMixed*=(bFinal/bMixed);\n  }\n  // 3-7) \u518d\u5ea6 RYB \u2192 RGB \u3078\u5909\u63db\u3057\u3066\u8fd4\u3059\n  return ryb2rgb(rybMixed);\n}\n// ------------------------------\n// 1)  sRGB \u2192 \u30ea\u30cb\u30a2\u5909\u63db (0~1 \u306e\u7bc4\u56f2)\n// ------------------------------\nfloat srgb_to_lin(float c){\n  return (c<=0.04045)\n  ? (c/12.92)\n  : pow((c+0.055)/1.055, 2.4);\n}\nvec3 from_sRGB(vec3 col){\n  return vec3(\n  srgb_to_lin(col.r),\n  srgb_to_lin(col.g),\n  srgb_to_lin(col.b)\n  );\n}\n// ------------------------------\n// 2)  \u30ea\u30cb\u30a2 \u2192 sRGB \u5909\u63db (0~1 \u306e\u7bc4\u56f2)\n// ------------------------------\nfloat lin_to_srgb(float c){\n  return (c<=0.0031308)\n  ? (12.92*c)\n  : (1.055*pow(c, 1.0/2.4)-0.055);\n}\nvec3 to_sRGB(vec3 col){\n  return vec3(\n  lin_to_srgb(col.r),\n  lin_to_srgb(col.g),\n  lin_to_srgb(col.b)\n  );\n}\n// ------------------------------\n// 3)  Mark\u3055\u3093\u306e\u30a2\u30eb\u30b4\u30ea\u30ba\u30e0\u3067 \u8272A/\u8272B \u3092\u77e5\u899a\u7684\u306b\u6df7\u8272\n//     (0~1 sRGB\u7a7a\u9593\u306e\u8272\u3092\u88dc\u9593)\n// ------------------------------\nvec3 perceptual_mix(vec3 colA, vec3 colB, float factor){\n  // 3-1) sRGB -> \u30ea\u30cb\u30a2\n  vec3 linA=from_sRGB(colA);\n  vec3 linB=from_sRGB(colB);\n  // 3-2) \u30ac\u30f3\u30de (0.43) \u3092\u4f7f\u3063\u305f\u300c\u64ec\u4f3c\u7684\u306a\u77e5\u899a\u7684\u660e\u308b\u3055\u300d\n  //      \u2192 sum(linA)^(gamma)\n  float gamma    =0.43;\n  float brightA  =pow(linA.r+linA.g+linA.b, gamma);\n  float brightB  =pow(linB.r+linB.g+linB.b, gamma);\n  // 3-3) \u660e\u308b\u3055\u3092 factor \u3067\u7dda\u5f62\u88dc\u9593 \u2192 perceptualIntensity\n  float perceptualIntensity=mix(brightA, brightB, factor);\n  float targetIntensity    =pow(perceptualIntensity, 1.0/gamma);\n  // 3-4) \u30ea\u30cb\u30a2RGB \u305d\u306e\u3082\u306e\u3082\u88dc\u9593\n  vec3 mixedLin=mix(linA, linB, factor);\n  // 3-5) \u88dc\u9593\u5f8c\u306e\u5408\u8a08\n  float sumC=mixedLin.r+mixedLin.g+mixedLin.b;\n  if(sumC>1e-10){\n    // (\u76ee\u6a19\u660e\u5ea6/\u5b9f\u969b\u306e\u5408\u8a08) \u3067\u30b9\u30b1\u30fc\u30eb\n    mixedLin*=(targetIntensity/sumC);\n  }\n  // 3-6) \u30ea\u30cb\u30a2 -> sRGB \u306b\u623b\u3057\u3066\u8fd4\u3059\n  return to_sRGB(mixedLin);\n}\n#define SMOOTH_HSV\n#ifdef SMOOTH_HSV\nvec3 hsv2rgb(in vec3 c){\n  vec3 rgb=clamp(abs(mod(c.x*6.0+vec3(0.0, 4.0, 2.0), 6.0)-3.0)-1.0, 0.0, 1.0);\n  rgb=rgb*rgb*(3.0-2.0*rgb);// cubic smoothing\n  return c.z*mix(vec3(1.0), rgb, c.y);\n}\n#else\nvec3 hsv2rgb(in vec3 c){\n  vec3 rgb=clamp(abs(mod(c.x*6.0+vec3(0.0, 4.0, 2.0), 6.0)-3.0)-1.0, 0.0, 1.0);\n  return c.z*mix(vec3(1.0), rgb, c.y);\n}\n#endif\n//From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c){\n  vec4 K=vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n  vec4 p=mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n  vec4 q=mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n  float d=q.x-min(q.w, q.y);\n  float e=1.0e-10;\n  return vec3(abs(q.z+(q.w-q.y)/(6.0*d+e)), d/(q.x+e), q.x);\n}\n//Linear interpolation between two colors in normalized (0..1) HSV space\nvec3 hsv_mix(in vec3 a, in vec3 b, in float x){\n  float hue=(mod(mod((b.x-a.x), 1.)+1.5, 1.)-0.5)*x+a.x;\n  return vec3(hue, mix(a.yz, b.yz, x));\n}// https://www.shadertoy.com/view/lsdGzN\nconst vec3 wref= vec3(1.0, 1.0, 1.0);\nfloat xyzF(float t){ return mix(pow(t, 1./3.), 7.787037*t+0.139731, step(t, 0.00885645));}\nfloat xyzR(float t){ return mix(t*t*t , 0.1284185*(t-0.139731), step(t, 0.20689655));}\nvec3 rgb2lch(in vec3 c){\n  c *=mat3(0.4124, 0.3576, 0.1805,\n  0.2126, 0.7152, 0.0722,\n  0.0193, 0.1192, 0.9505);\n  c.x=xyzF(c.x/wref.x);\n  c.y=xyzF(c.y/wref.y);\n  c.z=xyzF(c.z/wref.z);\n  vec3 lab=vec3(max(0., 116.0*c.y-16.0), 500.0*(c.x-c.y), 200.0*(c.y-c.z));\n  return vec3(lab.x, length(vec2(lab.y, lab.z)), atan(lab.z, lab.y));\n}\nvec3 lch2rgb(in vec3 c){\n  c=vec3(c.x, cos(c.z)*c.y, sin(c.z)*c.y);\n  float lg=1./116.*(c.x+16.);\n  vec3 xyz=vec3(wref.x*xyzR(lg+0.002*c.y),\n  wref.y*xyzR(lg),\n  wref.z*xyzR(lg-0.005*c.z));\n  vec3 rgb=xyz*mat3(3.2406, -1.5372, -0.4986,\n  -0.9689,  1.8758, 0.0415,\n  0.0557,  -0.2040, 1.0570);\n  return rgb;\n}\n//cheaply lerp around a circle\nfloat lerpAng(in float a, in float b, in float x){\n  float ang=mod(mod((a-b), TAU)+PI*3., TAU)-PI;\n  return ang*x+b;\n}\n//Linear interpolation between two colors in Lch space\nvec3 lch_mix(in vec3 a, in vec3 b, in float x){\n  float hue=lerpAng(a.z, b.z, x);\n  return vec3(mix(b.xy, a.xy, x), hue);\n}//---------------Improved RGB--------------\n// https://www.shadertoy.com/view/lsdGzN\n/*\nThe idea behind this function is to avoid the low saturation area in the\nrgb color space. This is done by getting the direction to that diagonal\nand displacing the interpolated\tcolor by it's inverse while scaling it\nby saturation error and desired lightness.\nI find it behaves very well under most circumstances, the only instance\nwhere it doesn't behave ideally is when the hues are very close\tto 180\ndegrees apart, since the method I am using to find the displacement vector\ndoes not compensate for non-curving motion. I tried a few things to\ncircumvent this problem but none were cheap and effective enough..\n*/\n//Changes the strength of the displacement\n#define DSP_STR 1.5\n//Optimizaton for getting the saturation (HSV Type) of a rgb color\n#if 0\nfloat getsat(vec3 c){\n  c.gb=vec2(max(c.g, c.b), min(c.g, c.b));\n  c.rg=vec2(max(c.r, c.g), min(c.r, c.g));\n  return (c.r-min(c.g, c.b))/(c.r+1e-7);\n}\n#else\n//Further optimization for getting the saturation\nfloat getsat(vec3 c){\n  float mi=min(min(c.x, c.y), c.z);\n  float ma=max(max(c.x, c.y), c.z);\n  return (ma-mi)/(ma+ 1e-7);\n}\n#endif\n//Improved rgb lerp\nvec3 nmz_mix(in vec3 a, in vec3 b, in float x){\n  //Interpolated base color (with singularity fix)\n  vec3 ic=mix(a, b, x)+vec3(1e-6, 0., 0.);\n  //Saturation difference from ideal scenario\n  float sd=abs(getsat(ic)-mix(getsat(a), getsat(b), x));\n  //Displacement direction\n  vec3 dir=normalize(vec3(2.*ic.x-ic.y-ic.z, 2.*ic.y-ic.x-ic.z, 2.*ic.z-ic.y-ic.x));\n  //Simple Lighntess\n  float lgt=dot(vec3(1.0), ic);\n  //Extra scaling factor for the displacement\n  float ff=dot(dir, normalize(ic));\n  //Displace the color\n  ic+=DSP_STR*dir*sd*ff*lgt;\n  return clamp(ic, 0., 1.);\n  }vec3 pow_mix(vec3 colA, vec3 colB, float h){\n  const vec3 gamma=vec3(16);\n  colA=pow(colA, 1./gamma);\n  colB=pow(colB, 1./gamma);\n  return pow(mix(colA, colB, h), gamma);\n}\nfloat sdSphere(vec3 p, float r){\n  return length(p)-r;\n}\nfloat sdPlane(vec3 p){\n  return p.y;\n}\nfloat sdBox(vec3 p, vec3 b){\n  p=abs(p)-b;\n  return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\nfloat sdEllipsoid(vec3 p, vec3 r){\n  float k0=length(p/r);\n  float k1=length(p/(r*r));\n  return k0*(k0-1.)/k1;\n}\nfloat sdTorus(vec3 p, vec2 t){\n  vec2 q=vec2(length(p.xz)-t.x, p.y);\n  return length(q)-t.y;\n}\nfloat sdCappedTorus(vec3 p, vec2 r, float per){\n  p.x=abs(p.x);\n  vec2 sc=vec2(sin(per), cos(per));\n  float k=(sc.y*p.x>sc.x*p.z) ? dot(p.xz, sc) : length(p.xz);\n  return sqrt(dot(p, p)+r.x*r.x-2.*r.x*k)-r.y;\n}\nfloat sdCappedCylinder(vec3 p, vec2 h){\n  vec2 d=abs(vec2(length(p.xz), p.y))-h;\n  return ((min(max(d.x, d.y), 0.)+length(max(d, 0.))));\n}\nfloat sdPieCylinder(vec3 p, float r, float h, float per){\n  per=mod(per, PI);\n  vec2 c=vec2(sin(per), cos(per));\n  p.xz=c.y*p.xz+c.x*vec2(p.z, -p.x);// rotation\n  p.x=abs(p.x);\n  float l=length(p.xz)-r;\n  float m=length(p.xz-c*clamp(dot(p.xz, c), 0., r));\n  float x=max(l, m*sign(c.y*p.x-c.x*p.z));\n  float y=abs(p.y)-h;\n  return ((min(max(x, y), 0.)+length(max(vec2(x, y), 0.))));\n}\nvec4 bUni(vec4 a, vec4 b){\n  return a.w<b.w ? a : b;\n}\nfloat bUniS(float a, float b, float r){\n  r*=1.35;\n  float h=max(r-abs(a-b), 0.)/r;\n  return min(a, b)-h*h*h*r*(1./6.);\n}\nvec4 bUniS(vec4 a, vec4 b, float r){\n  // float h=clamp(.5+.5*(b.w-a.w)/r, 0., 1.);\n  float h=smoothstep(0., 1., .5+.5*(b.w-a.w)/r);\n  float d=mix(b.w, a.w, h)-r*h*(1.-h);\n  return vec4(pow_mix(b.rgb, a.rgb, h), d);\n}\nvec4 bSub(vec4 a, vec4 b){\n  return (max(-a.w, b.w) == -a.w) ? vec4(a.rgb, -a.w) : b;\n}\nvec3 pRot(inout vec3 p, vec3 r){\n  #define r2d(v, a) v=cos(a)*v+sin(a)*vec2(v.y, -v.x)\n  r2d(p.xz, r.y);\n  r2d(p.yx, r.z);\n  r2d(p.zy, r.x);\n  return p;\n}\nvec4 sdScene(vec3 p){\n  float d=MAX_DIST;\n  vec4 res=vec4(MAT_VOID, d);\n  vec3 sdSphere02_p=p;\n  sdSphere02_p.xyz+=vec3(2.876788, -1.863764, -.036114);\n  d=sdSphere(sdSphere02_p, .612911);\n  res=bUni(vec4(MAT_ERNST0_011_COL, d), res);\n  \n  vec3 sdSphere03_p=p;\n  sdSphere03_p.xyz+=vec3(4.640138, -1.720752, -.021149);\n  d=sdSphere(sdSphere03_p, .612911);\n  res=bUniS(vec4(MAT_ERNST0_010_COL, d), res, 1.43668);\n  \n  vec3 sdSphere03_001_p=p;\n  sdSphere03_001_p.xyz+=vec3(5.415499, -2.885151, -.128223);\n  d=sdSphere(sdSphere03_001_p, .612911);\n  res=bUniS(vec4(MAT_ERNST0_014_COL, d), res, .808496);\n  \n  vec3 sdBox00_p=p;\n  sdBox00_p.xyz+=vec3(-2.032438, -2.685711, -.328315);\n  pRot(sdBox00_p, vec3(0));\n  d=sdBox(sdBox00_p, vec3(.902973, .902973, .902973)-.06)-.06;\n  vec3 sdBox00_001_p=p;\n  \n  sdBox00_001_p.xyz+=vec3(-2.00575, -2.971098, -.345337);\n  pRot(sdBox00_001_p, vec3(0));\n  d=bUniS(sdBox(sdBox00_001_p, vec3(.902973, .902973, .902973)-.06)-.06, d, .01);\n  res=bUniS(vec4(MAT_ERNST0_007_COL, d), res, .01);\n  \n  vec3 sdCappedCylinder00_p=p;\n  sdCappedCylinder00_p.xyz+=vec3(.531891, -2.506936, .5409);\n  pRot(sdCappedCylinder00_p, vec3(0));\n  d=sdCappedCylinder(sdCappedCylinder00_p, vec2(.953907, 1.785845)-.09)-.09;\n  res=bUniS(vec4(MAT_ERNST0_003_COL, d), res, .82);\n  \n  vec3 sdCappedTorus00_p=p;\n  sdCappedTorus00_p.xyz+=vec3(-.119818, -4.095171, .279885);\n  pRot(sdCappedTorus00_p, vec3(1.570796, 0., 0.));\n  d=sdCappedTorus(sdCappedTorus00_p, vec2(1., .5), 1.843616);\n  res=bUniS(vec4(MAT_ERNST0_004_COL, d), res, .4);\n  \n  vec3 sdEllipsoid00_p=p;\n  sdEllipsoid00_p.xyz+=vec3(-2.617105, -4.36887, .95226);\n  pRot(sdEllipsoid00_p, vec3(0));\n  d=sdEllipsoid(sdEllipsoid00_p, vec3(1.215524, 1.296544, 1.));\n  res=bUniS(vec4(MAT_ERNST0_005_COL, d), res, .7);\n  \n  vec3 sdPlane00_p=p;\n  sdPlane00_p.xyz+=vec3(0);\n  pRot(sdPlane00_p, vec3(0));\n  d=sdPlane(sdPlane00_p);\n  res=bUniS(vec4(MAT_ERNST0_002_COL, d), res, .52);\n  \n  vec3 sdSphere00_p=p;\n  sdSphere00_p.xyz+=vec3(.14608, -1.906251, -.993266);\n  d=sdSphere(sdSphere00_p, .832277);\n  res=bUniS(vec4(MAT_ERNST0_001_COL, d), res, .649);\n  \n  vec3 sdTorus00_p=p;\n  sdTorus00_p.xyz+=vec3(-1.971172, -1.301637, -.489569);\n  pRot(sdTorus00_p, vec3(0));\n  d=sdTorus(sdTorus00_p, vec2(1., .71));\n  res=bUniS(vec4(MAT_ERNST0_006_COL, d), res, .574);\n  \n  vec3 sdPieCylinder00_p=p;\n  sdPieCylinder00_p.xyz+=vec3(-2.968206, -.845974, .017411);\n  pRot(sdPieCylinder00_p, vec3(0));\n  d=sdPieCylinder(sdPieCylinder00_p, .832876, .832876, 3.141278);\n  res=bUniS(vec4(MAT_ERNST0_008_COL, d), res, .01);\n  \n  vec3 sdSphere04_p=p;\n  sdSphere04_p.xyz+=vec3(2.51909, -3.234557, .002026);\n  d=sdSphere(sdSphere04_p, .612911);\n  res=bUniS(vec4(MAT_ERNST0_013_COL, d), res, .791047);\n  \n  vec3 sdSphere05_p=p;\n  sdSphere05_p.xyz+=vec3(4.103182, -3.913714, -.070138);\n  d=sdSphere(sdSphere05_p, .612911);\n  res=bUniS(vec4(MAT_ERNST0_012_COL, d), res, 1.279634);\n  \n  vec3 sdSphere00_001_p=p;\n  sdSphere00_001_p.xyz+=vec3(-2.294557, -4.298796, .069983);\n  d=sdSphere(sdSphere00_001_p, .999999);\n  res=bSub(vec4(MAT_ERNST0_009_COL, d), res);\n  \n  vec3 sdSphere01_p=p;\n  sdSphere01_p.xyz+=vec3(-3.093231, -1.059482, -5.147611);\n  d=sdSphere(sdSphere01_p, .030757);\n  res=bUniS(vec4(MAT_ERNST0_008_COL, d), res, .28);\n  \n  return res;\n}\nvec4 intersect(vec3 ro, vec3 rd){\n  float d=0.;\n  vec3  m=vec3(0);\n  for (int i=0;i<ITERATION;i++){\n    vec4 res=sdScene(ro+d*rd);\n    m=res.rgb;\n    if (abs(res.w)<MIN_DIST || res.w>=MAX_DIST) break;\n    d+=res.w;\n    if (d>=MAX_DIST) break;\n  }\n  return vec4(m, d);\n}\nvec3 normal(vec3 p){\n  // Copy from iq shader.\n  // inspired by tdhooper and klems-a way to prevent the compiler from inlining map() 4 times\n  vec3 n=vec3(0.0);\n  for(int i=0;i<4;i++){\n    vec3 e=0.5773*(2.0*vec3((((i+3)>>1)&1), ((i>>1)&1), (i&1))-1.0);\n    n+=e*sdScene(p+0.0005*e).w;\n  }\n  return normalize(n);\n}\nfloat shadow(vec3 o, vec3 ldir){\n  float mint=.001;\n  float maxt=25.;\n  float k=40.;\n  float res=1.;\n  float t=mint;\n  for(int i=0;i<80;i++){\n    float h=sdScene(o+ldir*t).w;\n    res=min(res, k*h/t);\n    t+=h;\n    if(res<MIN_DIST || t>maxt) break;\n  }\n  return sat(res);\n}\n// \"Multi Level AO\" by iY0Yi\n// https://www.shadertoy.com/view/fsBfDR\nfloat aoSeed=0.;\nconst float MAX_SAMP=16.;\nfloat ao(vec3 p, vec3 n, float sphereRadius){\n  float ao=0.;\n  for(float i=0.;i<=MAX_SAMP;i++){\n    vec2 rnd=hash21(i+1.+aoSeed);\n    float scale=(i+1.)/MAX_SAMP;\n    scale=mix(.0, 1., pow(scale, .5));\n    rnd.x=(rnd.x*2.-1.)*PI*.5;\n    rnd.y=(rnd.y*2.-1.)*PI;\n    vec3 rd=normalize(n+hash21(i+2.+aoSeed).xyx);\n    rd.xy*=mat2(cos(rnd.x), sin(rnd.x), -sin(rnd.x), cos(rnd.x));\n    rd.xz*=mat2(cos(rnd.y), sin(rnd.y), -sin(rnd.y), cos(rnd.y));\n    rd*=sign(dot(rd, n));\n    float raylen=sphereRadius*scale;\n    vec3 rndp=p+normalize(n+rd)*raylen;\n    float res=sdScene(rndp).w;\n    ao+=res;\n    aoSeed++;\n  }\n  return ao/float(MAX_SAMP);\n}\n// https://hanecci.hatenadiary.org/entry/20130505/p2\n// http://www.project-asura.com/program/d3d11/d3d11_006.html\nfloat normalizedBlinnPhong(float shininess, vec3 n, vec3 vd, vec3 ld){\n  float norm_factor=(shininess+1.)/(2.*PI);\n  vec3 h =normalize(-vd+ld);\n  return pow(max(0., dot(h, n)), shininess)*norm_factor;\n}\nvec3 render(vec2 uv){\n  vec3 ro=ray.origin;\n  vec3 rd=ray.direction;\n  // ray march\n  vec4 res=intersect(ro, rd);\n  vec3 p=ro+res.w*rd;\n  vec3 m=pow(res.rgb, vec3(.4545));\n  vec3 fogCol=pow(AMB_COL, vec3(.4545));\n  vec3 col=fogCol;\n  if (res.w<MAX_DIST){\n    vec3 ldir=normalize(lit0.direction);\n    vec3 n=normal(p);\n    float lamb1=sat(dot(n, ldir))*(1./PI);\n    float lamb2=sat(dot(n, -ldir))*(1./PI);\n    float sh=shadow(p+n*.01, ldir);\n    float rgh=.0005;\n    float spec=normalizedBlinnPhong(1./rgh, n, rd, ldir);\n    float a=ao(p, n, .1);\n    a+=ao(p, n, 1.);\n    a/=2.;\n    float dif=lamb1*7.+lamb2*1.*a;\n    dif*=sh;\n    col*= dif*m;\n    // col+=fogCol*.5*a;\n    float intensity=10.;\n    spec=spec*intensity*sh*sh*sh;\n    col=mix(col, col+spec, spec*.1);\n    col=mix(col, fogCol, sat(pow(distance(ro, p)/MAX_DIST, .5)));\n  }\n  col=tanh(col);\n  return col;\n}\n// ---------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  vec2 uv=fragCoord.xy/iResolution.xy;\n  if(uv.x>INV_ERNST_RENDER_SCALE || uv.y>INV_ERNST_RENDER_SCALE) return;\n  uv*=ERNST_RENDER_SCALE;\n  float ml=(min(iResolution.x, iResolution.y)==iResolution.x)?1.0:iResolution.y/iResolution.x;\n  uv=(uv*2.-1.)*ml;\n  uv.x*=iResolution.x/iResolution.y;\n  init();\n  camera(uv);\n  vec3 col=render(uv);\n  col=mix(col, sms(0., 1., col), .25);\n  col=pow(col, vec3(.4545));\n  fragColor=vec4(col, 1);\n}"}], "flags": {"mFlagVR": false, "mFlagWebcam": false, "mFlagSoundInput": false, "mFlagSoundOutput": false, "mFlagKeyboard": false, "mFlagMultipass": true, "mFlagMusicStream": false}, "info": {"id": "-1", "date": "1358124981", "viewed": 0, "name": "", "username": "iY0Yi", "description": "", "likes": 0, "hasliked": 0, "tags": [], "published": 0}}